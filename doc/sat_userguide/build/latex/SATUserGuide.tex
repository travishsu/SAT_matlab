% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{SAT User Guide Documentation}
\date{August 27, 2014}
\release{0.8}
\author{NTU COLA Lab}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{intro:introduction}\label{intro::doc}\label{intro:surrogate-based-auto-tuning-sat-user-guide}

\section{Preface}
\label{intro:preface}
Surrogate-Based Auto Tuning (SAT) package is a collection of MATLAB code used for stochastically optimization based on the Kriging modeling method. \textbf{demo\_kriging.m} and \textbf{demo\_cokriging.m}  can be referred to for an intuitive look in the function of this package.

This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser Public License for more details.

You should have received a copy of the GNU General Public License and GNU Lesser Public License along with this program. If not, see \textless{}\href{http://www.gnu.org/licenses/}{http://www.gnu.org/licenses/}\textgreater{}.


\section{SAT Framework}
\label{intro:sat-framework}
SAT brief framework:

\begin{Verbatim}[commandchars=\\\{\}]
Initialization;
while stopping criteria is not satisfied:

    Modeling;
    Infilling;

endwhile
\end{Verbatim}


\section{Stochastical Modeling Method}
\label{intro:stochastical-modeling-method}
Target to different objective problems, SAT provided several types of Kriging as following:
\begin{itemize}
\item {} 
Kriging

\item {} 
Co-Kriging

\item {} 
Derivative-enhanced Kriging (coming soon)

\end{itemize}


\chapter{Data Arrangement}
\label{data::doc}\label{data:data-arrangement}
In SAT package,
we require user to give data a specified form which is readable by SAT machine.


\section{Training Set}
\label{data:training-set}
We require each sample and its corresponding value are row-wisely permuted:

\begin{Verbatim}[commandchars=\\\{\}]
samples = [sample1; sample2; sample3];
values  = [value1 ; value2 ; value3 ];
\end{Verbatim}


\section{Commonly Used Variables}
\label{data:commonly-used-variables}
Variable's names in \textbf{demo\_kriging.m} and \textbf{demo\_cokriging.m} are easy to understand what it means.

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Variable name
} & \textsf{\relax 
Description
}\\
\hline
numDim
 & 
Dimension number of objective function
\\

numInitial
 & 
Number of initial samples
\\

samples
 & 
Coordinates of current training set
\\

values
 & 
Values of current training set
\\
\hline\end{tabulary}



\chapter{Initialization}
\label{initial:initialization}\label{initial::doc}

\section{Problem Definition}
\label{initial:problem-definition}

\subsection{Constant Variables}
\label{initial:constant-variables}\begin{itemize}
\item {} 
\textbf{numDim}

\item {} 
\textbf{maxIteration}

\item {} 
\textbf{maxTime}

\end{itemize}


\subsection{Function Evaluation}
\label{initial:function-evaluation}
In optimization procedure, it always asks to evaluate function value at a series of points repeatly, in this User Guide we assume objective function called \textbf{YourFunc}, this function outputs a real value:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{value} \PYG{o}{=} \PYG{n}{YourFunc}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\subsection{Search Region}
\label{initial:search-region}
Our model can predict everywhere in space same as samples, but to predict the value at some point far far away from training data is meaningfulless, since training set has tiny even no influence to that points.

You are required to set a rectangular region \textbf{window} where we select sample at every iteration:

\begin{Verbatim}[commandchars=\\\{\}]
window = [x\PYGZus{}lb, x\PYGZus{}ub, y\PYGZus{}lb, y\PYGZus{}ub]

\PYGZpc{} x\PYGZus{}lb: lower bound in x\PYGZus{}axis
\PYGZpc{} x\PYGZus{}ub: upper bound in x\PYGZus{}axis
\PYGZpc{} y\PYGZus{}lb: lower bound in y\PYGZus{}axis
\PYGZpc{} y\PYGZus{}ub: upper bound in y\PYGZus{}axis
\end{Verbatim}

Here we assume \textbf{numDim} is 2, then we define \textbf{window} as a rectangular region, \textbf{window} will be a 1-by-2*2 (1-by-2*numDim) vector.


\section{Observation Grid}
\label{initial:observation-grid}
Given a vector of alternating corresponding lower and upper bounds along with a vector of the corresponding \textbf{gridsize}, construct multiple return values for reshaping the structure. It returns a integer number length of the number of observation points in the grid, a length by k matrix called grid containing every observation point in every row, a length by 1 vector matrix called \textbf{P} for containing the prediction value corresponding to ever observation point, a length by 1 vector called \textbf{MSE} for containing the mean square error corresponding to every observation point, and a length by 1 vector called \textbf{EI} for containing the expected improvement corresponding to every observation point. The output vectors, \textbf{P}, \textbf{MSE}, and \textbf{EI} do not contain actual values from this function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{gridLen}\PYG{p}{,} \PYG{n}{G}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{MSE}\PYG{p}{,} \PYG{n}{EI}\PYG{p}{]} \PYG{o}{=} \PYG{n}{grid\PYGZus{}cut}\PYG{p}{(}\PYG{n}{window}\PYG{p}{,} \PYG{n}{gridsize}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}
\begin{itemize}
\item {} \begin{description}
\item[{Input}] \leavevmode\begin{itemize}
\item {} 
\textbf{window}  :  {[}lb1, ub1, lb2, ub2, ..., lbk, ubk{]}

\item {} 
\textbf{gridsize}:  {[} g1,  g2, ...,  gk{]}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Output}] \leavevmode\begin{itemize}
\item {} 
\textbf{gridLen} :  Integer number, number of observation points in grid

\item {} 
\textbf{G}       :  gridLen-by-k matrix, list every observation point in every single row

\item {} 
\textbf{P}       :  gridLen-by-1 vector, list for fill with prediction value corresponding to every observation point

\item {} 
\textbf{MSE}     :  gridLen-by-1 vector, list for fill with mean square error corresponding to every observation point

\item {} 
\textbf{EI}      : gridLen-by-1 vector, list for fill with expected improvement corresponding to every observation point

\end{itemize}

\end{description}

\end{itemize}

Variable \textbf{gridsize} means how dense observation set to list, it is a 1-by-numDim vector, each component represent how many grid to cut in each axis.


\section{Latin Hypercube Design}
\label{initial:latin-hypercube-design}
For \textbf{numDim}-dimensional region bounded in \textbf{window}, generate a Latin-Hypercube Design. Requires an integer representing the number of designs \textbf{numInitial}, an integer representing the dimension of designs \textbf{numDim} and a 1 by 2*numDim vector representing the regionâ€™s edges in each dimension window. Will output a \textbf{numInitial} by \textbf{numDim} matrix over a region in \textbf{window} Initial:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{samples} \PYG{o}{=} \PYG{n}{LHD}\PYG{p}{(}\PYG{n}{numInitial}\PYG{p}{,} \PYG{n}{numDim}\PYG{p}{,} \PYG{n}{window}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\section{Training Set Initialization}
\label{initial:training-set-initialization}
Constructing Kriging model needs a set of training data.


\subsection{Kriging}
\label{initial:kriging}
Put objective data in values:

\begin{Verbatim}[commandchars=\\\{\}]
values = zeros(size(samples, 1), 1);
for idx = 1:size(samples, 1)
    values(idx) = YourFunc(samples(idx,:));
end
\end{Verbatim}


\subsection{Co-Kriging}
\label{initial:co-kriging}
In Co-Kriging modeling method, it's supposed that there are available to use two fidelities of evaluation function, they are supposed to solve the same problem but have different levels of approximation.

One of them has more accurate, Co-Kriging will construct surrogate for high-fidelity objective.


\chapter{Modeling}
\label{modeling:modeling}\label{modeling::doc}

\section{Kriging}
\label{modeling:kriging}
Given \textbf{N} data with dimension \textbf{numDim}, create a handle of the Kriging model. In this function \textbf{samples} is a \textbf{n} by \textbf{numDim} matrix of sample(feature data) and \textbf{values} is an \textbf{n} by 1 vector that corresponds with \textbf{samples}. Outputs \textbf{model} structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Kmodel} \PYG{o}{=} \PYG{n}{Kriging\PYGZus{}info}\PYG{p}{(}\PYG{n}{samples}\PYG{p}{,} \PYG{n}{values}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

The Kriging kernel function output \textbf{Kmodel}, that is the handle of current model.

Based on the info generated in the function Kriging\_info, this function predicts the value y and mean square error mse at the points contained in x:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{y}\PYG{p}{,}\PYG{n}{mse}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Kriging\PYGZus{}pred}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{Kmodel}\PYG{p}{)}
\end{Verbatim}

In demo script, we predict all points in observation list:

\begin{Verbatim}[commandchars=\\\{\}]
for i = 1:gridLen
    [P(i), MSE(i)] = Kriging\PYGZus{}pred(G(i, :), Kmodel);
    EI(i) = eiMaximum(P(i), values, MSE(i));
    \PYGZpc{} EI(i) = eiMinimum(P(i), values, MSE(i));
end
\end{Verbatim}


\section{Co-Kriging}
\label{modeling:co-kriging}
Suppose there are two sets of data:
\begin{itemize}
\item {} 
High fidelity data: \textbf{samples\_high} and \textbf{values\_high}.

\item {} 
Low fidelity data : \textbf{sample\_low} and \textbf{values\_low}.

\end{itemize}

Given the inputs matrix \textbf{samples\_high}, \textbf{samples\_low}, \textbf{values\_high} and \textbf{values\_low}, declares the global variables ModelInfo.Xe, ModelInfo.Xc, ModelInfo.ye, and ModelInfo.yc respectively. This function generates and stores the information about the corresponding co-kriging model as a global variable and outputs it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{CKmodel} \PYG{o}{=} \PYG{n}{coKriging\PYGZus{}info}\PYG{p}{(}\PYG{n}{samples\PYGZus{}high}\PYG{p}{,} \PYG{n}{samples\PYGZus{}low}\PYG{p}{,} \PYG{n}{values\PYGZus{}high}\PYG{p}{,} \PYG{n}{values\PYGZus{}low}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Given the input scalar x and the input structure CKmodel, this function will construct a function f\_hat to model the given data from the four matrices inside the Info structure. It will output this function as well as a generated error mse using the mean square error:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{f\PYGZus{}hat}\PYG{p}{,}\PYG{n}{mse}\PYG{p}{]} \PYG{o}{=} \PYG{n}{coKriging\PYGZus{}pred}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{CKmodel}\PYG{p}{)}
\end{Verbatim}

Prediction all points:

\begin{Verbatim}[commandchars=\\\{\}]
for i = 1:gridLen
    [P(i), MSE(i)] = coKriging\PYGZus{}pred(G(i, :), CKmodel);
    EI(i) = eiMaximum(P(i), values, MSE(i));
    \PYGZpc{} EI(i) = eiMinimum(P(i), values, MSE(i));
end
\end{Verbatim}


\chapter{Uncertainty Measurement}
\label{modeling:uncertainty-measurement}

\section{Mean Square Error (MSE)}
\label{modeling:mean-square-error-mse}
Kriging has some useful stochastical properties, it has been  developed to have ability to  measure the uncertainty of surrogate,


\section{Expected Improvement (EI)}
\label{modeling:expected-improvement-ei}
Target to
\begin{itemize}
\item {} 
Maximization Problem, use \textbf{eiMaximum}.

\item {} 
Minimization Problem, use \textbf{eiMinimum}.

\end{itemize}


\chapter{Infilling}
\label{infilling::doc}\label{infilling:infilling}

\section{New Sampling}
\label{infilling:new-sampling}
If your object problem is a optimization:

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZti{}, new\PYGZus{}idx] = max(EI);
\end{Verbatim}

If your goal is to make model more fitting:

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZti{}, new\PYGZus{}idx] = max(MSE);
\end{Verbatim}


\section{Evaluate and Append}
\label{infilling:evaluate-and-append}
A stupid method:

\begin{Verbatim}[commandchars=\\\{\}]
new\PYGZus{}sample = G(new\PYGZus{}idx, :);
new\PYGZus{}value = YourFunc(new\PYGZus{}sample);


samples(end+1, :) = new\PYGZus{}sample;
values(end+1, :) = new\PYGZus{}value;
\end{Verbatim}


\chapter{``Zoom in'' Strategy}
\label{zoomin::doc}\label{zoomin:zoom-in-strategy}

\section{Brief Idea}
\label{zoomin:brief-idea}
To find the optimal solution, shrink the search region might accelerate optimization procedure.


\section{Shrink Search Region and Create New Window}
\label{zoomin:shrink-search-region-and-create-new-window}
This function determines a new smaller window and locates the position of edge. The optimal sample in the data set is chosen as the center of the new data. Requires the training set \textbf{samples} and \textbf{values}, a 1 by 2*numDim vector info of old window \textbf{window\_old}, a 1 by \textbf{numDim} vector specifying the ratios in every dimension \textbf{shrink\_ratio}, and to set \textbf{opt\_prob} to be either \textbf{max} or \textbf{min}. The output is a 1 by 2*numDim vector of the info of the new window:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{window\PYGZus{}new} \PYG{o}{=} \PYG{n}{zoom\PYGZus{}shrink\PYGZus{}Window}\PYG{p}{(}\PYG{n}{samples}\PYG{p}{,} \PYG{n}{values}\PYG{p}{,} \PYG{n}{window\PYGZus{}old}\PYG{p}{,} \PYG{n}{shrink\PYGZus{}ratio}\PYG{p}{,} \PYG{n}{opt\PYGZus{}prob}\PYG{p}{)}
\end{Verbatim}


\section{Drop Off Samples Not Belong to New Window}
\label{zoomin:drop-off-samples-not-belong-to-new-window}
This function drops off the samples which are outside the window. Requires a 1 by 2*numDim vector info of window region \textbf{window}, an N by \textbf{numDim} matrix of sample (feature data) \textbf{samples}, and an N by 1 vector corresponding to \textbf{samples} response \textbf{values}. The output \textbf{samples\_new} is an N by \textbf{numDim} matrix with updated samples and values\_new is an N by 1 vector of the updated responses:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{samples}\PYG{p}{,} \PYG{n}{values}\PYG{p}{]} \PYG{o}{=} \PYG{n}{zoom\PYGZus{}shrink\PYGZus{}dropoutside}\PYG{p}{(}\PYG{n}{window}\PYG{p}{,} \PYG{n}{samples}\PYG{p}{,} \PYG{n}{values}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\section{Disadvantage}
\label{zoomin:disadvantage}
On the other hand, this strategy might converge to local optimum


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
